【VIM】vi与vim编辑器（进阶篇）
------


## 命令组合
   change |   delete  |   yank   |   move   |
----------|-----------|----------|------------
  cH      |    dH     |   yH     |  屏幕顶端  |
  cL      |    dL     |   yL     |  屏幕底端  |
  c+      |    d+     |   y+     |  下一行    |
  c5l（竖杠） |   d5l（竖杠） |   y5l（竖杠） |   本行第5列 |
  2c)     |    2d)    |   2y)    |  往下第二个|
  c{      |    d{     |   y{     |  上一段    |
c/pattern | d/pattern | y/pattern| pattern(模式)|
cn  | dn|  yn| 下一个模式|
cG | dG| yG| 文件结尾|
c12G|d12G|y12G|第12行|

**注意**：上表命令的一般形式是：

> *(number)  (command) (text object)*

其中number是可有可无的数值参数，而command是c，d或者y，text object是一个移动命令

## 打开vi的选项
### 特定位置打开
> $ vi +*n file* ==>> 在第n行打开（“+”后面没空格）

> $ vi +*file* ==>> 在最后一行打开（“+”后面没空格）

> $ vi +*/pattern file* ==>> 在第一个出现pattern的地方打开file

如果pattern包含空格，需要使用双引号或者“\”进行转义；当编辑到一半必须离开的时候，可以使用/ZZZ或者/HERE，快速继续。

### 只读模式
> $ vi -R *file*

> $ view  *file* ==>> 可被:w!或者:wq!覆盖

### 恢复缓冲区
突然退出的时候，会生成缓冲文件。

> $ ex -r 或者 vi -r可以打开

## 善加利用缓冲区
### 恢复删除
vim有9个缓冲区，可以保留前9次删除的操作。如想恢复第二次的删除操作，”引号“ + 缓冲区编号 + 放置命令

> "2p

如果不确定恢复哪一缓冲区，可以使用”.“进行连续恢复，再使用”u“就是撤销，类似：

>  "1pu.u.u

### 将文本拖拽到缓冲区

拖拽：

> “ + 拖拽命令 + 缓冲区名（用字符表示）

取回：

>  ” + 放置命令

> "dyy ==>> 将当前行拖入缓冲区d

> a7yy ==>> 将后续7行拖拽到缓冲区a中

> ”dP ==>> 将缓冲区d的内容放置在光标前

> “ap ==>> 将缓冲区a的内容放置在光标后

如果你使用大写字母作为缓冲区的名字，那么缓冲的内容会被加入到当前缓冲区中。

> ”zd) ==>> 删除从光标处开始到句子结尾处的内容，并保留到缓冲区z中。

> 2) ==>> 向前（→）两个句子

> ”Zy) ==>> 将下一个句子添加到缓冲区中

**注意**：如果没有使用大写字母，则会把缓冲区的内容覆盖掉。

### 对一处做标记

> m*x* ==>> 将当前位置标记成*x

> 'x ==>> (单引号) 将光标移动到x所在行行首

> ’x ==>> (反引号) 将光标移动到x所在

>  `` ==>> 移动位置之后，回到上一个标记

>  ' ' ==>> 回到上一个标记所在

**注意**：标记只在当前vi会话中有用，不会存储在文件中。

## ex编辑器概述
**提示**：文件名应该避免包含空格

> ex hello_vi

> 1,3p ==>> print lines between 1,3

### 说明
- 没有行号，就是对当前行起作用
- :s ==>> 替换命令
- vi编辑器输入Q会调用ex；ex编辑器输入vi回到vi

> :1s/screen/line

## 用ex编辑
### 说明
- 指定明确行号
- 用符号来指定相对于当前位置的行号
- 表示某些行的搜索模式作为地址
- 符号
    - d <=> delete
    - m <=> move
    - co <=> copy
    - t <=> 同co

### 定义行范围
> :3,17d ==>> 删除第3到第18行

> :160,224m23 ==>> 将第160行到224行移动到23行之后（类似vi的delete与put）

> :23,29co100 ==>> 将第23到29行复制到100行之后（类似vi的yank与put）

> :1,10# ==>> 暂时显示第1到10行的行号。

> ctrl + G 或者 := -->> 总行数

> ：.= -->> 当前行

> :/pattern/= -->> 列出pattern第一次出现时的行号

## 行寻址符号
### 绝对行寻址
> :.,$d ==>> 删除当前行到文件结尾的文本, "."可以换成数字n，表示从n行开始删除

> :%d ==>> 删除文件中的所有行

> %t$ ==>> 复制所有的行复制到文件结尾（做连续的复制）

### 相对行寻址
> :.,.+20d ==>> 删除之后的20行

> :226,$m.-2 ==>> 将226行到文件结尾移动到当前之一行的前两行

> :.,+20# ==>> 改行及之后20行行号文本

> :-,+t0 ==>> 复制3行（光标上面一行到光标下面一行）并放置到文件开头

### 搜索模式
> :/pattern/d ==>> 删除下一个包含pattern的行

> :/pattern/+d ==>> 删除下一个包含pattern的下一行（可以用+1代替）

> :/pattern1/,/pattern2/d ==>> 从包含pattern1的行删除到包含pattern2的行

> :.,/pattern/m23 ==>> 将当前行(.)到包含第一个pattern的行之间的文本放到23行之后

**注意**:这些模式都需要斜线作为分界.

### 重新定义当前这一行的位置
> :100,+5 p //**错误示范**:这里并不是打印100行之后的5行,第二个位置是相对于当前位置的

> :100,6 p //打印100行之后的6行

> :100;+5 p //ex编辑器提供了一个分行来代替逗号,让编辑器认为分号前为当前行地址

> :/pattern/;+10 p //包含pattern模式的下一行及后续10行

### 全局搜索
> :g/pattern ==>> 寻找(移动)到文件中最后一层出现pattern的地方

> :g/pattern/p ==>> 寻找并显示文件中所有包含pattern的行

> :g!/pattern/nu ==>> 寻找并显示文件中所有不包含pattern的行及行号

> :60,124g/pattern/p ==>> 寻找并显示第60行到第124行之间包含pattern的行

### 合并ex命令
> :1,3d | s/thier/their/  ==>> 删除第1-3行,接着在当前行(原第4行)做替换

> :1,5 m 10 | g/pattern/nu ==>> 将第1行到第5行移动到第10行之后,接着显示所有包含pattern的行及行号.

**注意**: 空格的使用能够增加命令可读性

### 保存与离开文件
> :w、:q、 :wq 、:x（ZZ）

### 更改缓冲区名称
> :w filename // 之前未用过:w

### 保存一部分文件
> :230,$w newfile ==>> 将第230行到文件结尾保存为newfile

> :.,600w newfile ==>> 将光标所在到第600行保存成名为newfile的文件

### 附加内容到已保存的文件
newfile保存第1-10行及第340行到文件结尾

```
    :1,10w newfile
    :340,$w >> newfile
```
### 文件复制
> :read filename 或 :r filename

一下是读入文件的几种格式:

> :185r /home/time/data ==>> 在185行之后插入data文件

> $r /home/time/data ==>> 将读入的文件放在文件结尾

> :0r /home/time/data ==>> 将读入的文件放在当前文件的开头

> :/pattern/r /home/time/data ==>> 将读入的文件放在第一个出现pattern的行之后

## 编辑多个文件
### vi同时打开多个文件
> $ vi file1 file2 //按键顺序如下

```
  vim practice note
  :w //保存practice
  :n //切换到下一个
```

### 使用参数列表

```
    vi hello.html hi.py test.css welcome.txt
    :ar(或者:args) //[hello.html] hi.py test.css welcome.txt
    :n //向后移动
    :rewind //向前移动(简写:rew)
    :last //最后一个
    :e filename //跳到指定文件
```

### 在文件之间做编辑
方法A:使用yy和p配合缓冲区

```
    f4yy //将4行文本拖拽到缓冲区f
    :w //保存文件
    :e letter //跳转到letter文件.
    //移动光标到要放置的地方
    fp //从命名f的缓冲区中的文本放到光标处
```

方法B:使用ex命令:ya (拖动) 与:pu (放置)配合缓冲区

```
    :160,224ya a //把practice文件的160-224行放置到a缓冲区
    :e letter //跳转到letter文件
    //移动光标到要放置的位置
    :pu a //将缓冲区a的内容放置到当前行所在的下一行
```

## 全局变量
> :s/old/new ==>> 将这一行第一个old换成new

> :s/old/new/g ==>> 将这一行每一个old换成new,不要与ex的:g混淆

> :50,100s/old/new/g(c) ==>> 将50到100行的old换成new,可选参数c,confirm之意

> :%s/old/new/g ==>> 同 :1,$s/old/new/g(c)

一些快捷键:

```
    n ==>> 重复上一次搜索
    . ==>> 重复上一个命令
    // 组合使用, 修改某些将that使用成which的情况
    ------
    /which //搜索which
    cwthat[ESC] //改成that
    n //重复搜索
    n //重复搜索,省略一次改变
    . //如果需要改变
```

### 与上下文相关的替换
> :g/pattern/s/old/new/g ==>> :对所有行起作用/含有pattern的行/搜索当前行/ex将old换成new/本行做全局替换

> :g/editer/s//editor/g(不推荐) <=> :g/editer/s/editer/editor/g(不推荐) <=> :%s/editer/editor/g(推荐)

## 匹配模式的规则
### 用在搜索模式中的元字符
> . ==>> 匹配任何单一字符(换行符除外),请记住**空格**也是字符.

> * ==>> 匹配任何组合字符,可出现**零**到多次.

> .* ==>> 任何数量的任何字符

> ^ ==>> 位于开头就是正则表达式开头,位于后面就是本意

> $ ==>> 位于正则表达式结尾,它前面的正则表达式必须位于一行的结尾

> \ ==>> 转义字符

> [] ==>> 匹配方括号里的任意字符 [:;A-Za-z0-9],若[]中第一个是^,则不会匹配[]内的字符

> \( \) ==>> 会将\(和\)之间的模式保存到"保留缓冲区" 之后可以通过任意1-9数字调用

```
    实例:
    :%s/\(That\) or \(this \)/\2 or \1/ ==>> 将 That or that <-> that or That
    :s/\(abcd\)\1/alphabet-soup/ ==>> 将abcdabcd <-> alphabet-soup
```

> \< '\>' ==>> 会匹配以某些字符开头或结尾的单字\<+ac匹配action; 像ac+\> 会匹配maniac,但不会匹配react

> ~ ==>> 会匹配任何上一次搜索时所使用的正则表达式

### POSIX 方括号表达式

```
    方括号表达式匹配规则
    字符类 ==>> [:与:]
    校对符号 ==>> [.与.]
    等价类 ==>> [=与=]
    实例:
    [[:alpha:]!] ==>> 匹配任何一个字母字符或者感叹号
    [[.ch.]] ==>> 匹配处校对符号
    [[=e=]] ==>> 法语系中可能匹配带声调的e
```

表: POSIX字符类型

类型|比较出的字符|
-------|----------
[:alnum:]|字母+数字字符|
[:alpha:]|字母字符|
[:blank:]|空格+制表字符|
[:cntrl:]|控制字符|
[:digit:]|数字字符|
[:graph:]|可打印和可见的字符|
[:lower:]|小写字符|
[:upper:]|大写字符|
[:print:]|可打印字符|
[:punct:]|标点字符|
[:sapce:]|空白字符|
[:xdigit:]|十六进制数字|

### 用在替换字符串中的元字符
(跳过)

### 更多的替换技巧
> :%/yssss/&,Nooo/  ==>> &可以表示搜索处的字符

> :s/old/new/g
> :set edcompatible ==>> 接下来的替换都是全局的

### 模式匹配的范例
思考一下两条命令:

```
%s/child+\([ ,.;:!?]\)/children\1/g
%s/\<child\>/children/g
```

### 用模式移动文本块
现有150页,每页有三个标题: SYNTAX, DESCRIPTION, PARAMETERS
假设决定将DESCRIPTION块移动到SYNTAX块之上,利用匹配模式执行,只需要一个命令

> :g /SYNTAX/.,/DESCRIPTION/-1 move /PARAMETERS/-1

```
    说明:
    1 ex会寻找并标记匹配第一个模式的每一行(本领为包含/SYNTAX/的行)
    2 逐一对标记行设置.(点号,表示当前行),在执行命令
    3 move从当前这一行(.)起到包含PARAMETERS的前一行(/PARAMETERS/-1)间的内容
        一起移动到包含DESCRIPTION的上一行(/DESCRIPTION/-1)
```

**注意**:ex只能把文本放置在指定位置之后, 之前需要进行减一操作

> :g/DESCTIPTION/,/PARAMETERS/-1d ==>> 删除所有的DESCRIPTION(从包含/DESCRIPTION/到/PARAMETERS/-1删除)

### 更多范例
(显示方便,用_代替)

> :%s/RETURN/\\fI&\\fP/g ==>> 在单词ENTER前后加入troff的斜体代码

> :%s/\home\/tim/\home\/linda/g ==>> 更换文件路径 <=> :%s:/home/tim:/home/linda:g(推荐)

> :%s:ENTER:&:g ==>> 将ENTER前后加上HTML的斜体代码

> :1,10s/\./;/g ==>> 将第1-10行的所有句号改为分号:

> :%s[Hh]elp/HELP/g ==>> 将Help和help转化成HELP <=> :%s/[Hh]elp/\U&/g ==>> \U会将后面的模式改为大写,随后的模式可能是重复搜索

> :%s/ __*/_/g ==>> 将多个空格替换成一个空格(前面是两个后面是一个)

> :%/\([:.]\)__*/\1__/g ==>> 将句号或者冒号后面的一个或者多个空格转换成两个空格,方括号中的特殊字符不需要转义

> :%s/^Note[_:s]*/Notes:_/g

```
    说明:
        括号中的三个字符:空格,冒号,字母s会匹配出Note_,Notes或者Note:
        后面的*号会使Note或者Notes:(正确的拼法)也会被匹配出来
        如果不加*,Note可能会被漏掉,Notes:可能会被错误的换成 Notes:_:
```

> :g/^[ tab]*$/d ==>> 删除所有空白行及只包含空格的行

> :g/^[ tab][ tab]*$/d ==>> 不删除空行,删除至少包含一个空格或者定位符的行

> :%s/^  *\(.*\)/\1/ ==>> 删除每一行开头所有空白(用^__*搜索所有空格,\(.*\)保存非空格字符,\1恢复)

> :%s/\(.*\) *$/\1/ ==>> 删除行尾的空白,本例与上例仅作用一次,因此不需要加g

> :%s/^/>   ==>> 每行开头加>__

> :.,+5s/$/./ ==>> 为后续5行添加句号

> :%s/\(.*\) - \(.*\)/\2 - \1/ ==>> 把类似 more - display files <-> display files - more

> :$s/.*/\U&/g ==>> 将文件中的每一个单词全部变成大写 <=> :%s/./\U&/g(不推荐)

> :g/.*/mo0  ==> 逆转文件中各行的次序 <=> :g/^/mo0(推荐)

> :g!/Paid_in_full/s/$/Overdue ==>> 对不包含Paid in full的行加上Overdue <=> :v/Paid_in_full/s/$/Overdue/

 > :g!/^[0-9]/m$ ==>> 将所有不是由数字开头的行移动到文件结尾 <=> :g/^[^0-9]/m$

 > :%s/^[1-9][0-9]*\.[1-9]/.Ah/ ==>> 小标题替换成troff宏

 > :%s/^[1-9][0-9]*\.[1-9][0-9.]*_// ==>> 删除小标题前的数字

 > :%s/\(For\)\(tran\)/U\1\2\E_(acronym_of_\U\1\Emula\_\U\2\Eslation)/g ==>> 将单词Fortran改成短语FORTRAN (acronym of FORmula Translation)

 **注** \U 大写 \E 撤销大写

## 匹配模式最后的叮咛
(作为本章总结)
### 删除未知文本块
> .* ==>> 可以匹配任意数量的字符,会进行贪婪匹配(尽可能多的匹配),有时候需要非常多的限制

### 在文本数据库中交换条目
例如交换姓和名
```
Name: Feld, Ray; Areas: PC, Unix; Phone: 123-4567
Name: Joy, Susan S.; Areas: Graphics; Phone: 999-3333
```
> :g/^Name/s/: *\([^,]*\), \([^;]*\);/: \2 \1;/

### 用:g重复执行命令
> :g/mg[ira]box/s/box/square/g

> :g/^$/d

> :1,10g/^/ 12,17t$ ==>> 当前文件的第12-17行复制10份放到文件结尾

## 高级编辑方法
### :set命令
作用|option|nooption|other|
------|----------|------|------
搜索忽略大小写|:set ic |:set noic||
显示窗口行数|||window=20|
正在使用选项|||:set all|
获取选项状态|||:set window?|

### .exrc文件
位于主目录,没有可以创建

### 其他环境
除了exrc,还可以导入其他的环境

```
    用于编程
    set number autoindent sw=4 terse
    set targs=/usr/lib/tags
    用于文本编辑
    set wrapmargin=15 ignorecase
```
也可保存.exrc之外的设置,并使用:so命令导入(source缩写)
> :so .progoptions

### 执行 Unix命令
> :!command ==>> 包括date,ls

> :sh ==>> 若想输入多行命令,不加!

> :r !tree -L 3

## 通过命令过滤文本
### 用ex过滤
> :96,99|sort

### 用vi过滤文本
> !)command

> !) ==>> 过滤一个句子

> tr '[:lower:]' '[:upper:]'

> | object| ==>> 重复前一个命令

## 保存命令
### 单词缩写
> :ab abbr phrase

> :ab imrc International Materials Research Center

> :unab abbr ==>> 不展开

> :ab ==>> 列出当前缩写

### 使用map命令
> :map x sequence ==>> 定义字符x映射到一个编辑命令sequence

> :unmap x ==>> 取消x映射

> :map ==>> 列出所有映射字符

> :map v dwelp

```
    实例:
        现有语句:
            you can the scroll page
            dwelp: 删除一个单词dw; 移动到下一个单词结尾e;向右移动一格1;p用来放置删除的单词
```

### 保护按键免被ex解释
必须用CTRL-V转义与系统冲突的按键
换行^M 转义^[ 退格 ^H; ^T ^W ^X必须转义(不只是map)
> :map CTRL-A sequence

> :map CTRL-V CTRL-T sequence

> :ab 123 one^Mtwo^Mthree

(部分实例,略)
